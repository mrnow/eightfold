End  = :a*.>aa.
End2 = :a*.>aEnd a.

## Show ~ write only string ##

Show : *.
+ : End2Show.

## Booleans ##

Bool = End2.

True : Bool = :a*,xa,ya.x.
False: Bool = :a*,xa,ya.y.

If
  : :a*.>Bool(Bool a)
  = :a*,xBool,ya,za.xayz.

Not
  : >BoolBool
  = :xBool.IfBool xFalseTrue.

"True" : Show.
"False" : Show.
Bool_show
  : >BoolShow
  = :xBool.IfShow x"True""False".

?? Bool_show(NotTrue).
?? Bool_show(NotFalse).

## Pairs ##

Pair = :a*,b*,c*.>(>a>bc)c.

Mk_pair : :a*,b*.>a>b Pair ab
        = :a*,b*,xa,yb,c*,f(>a>bc).fxy.

Pi1 : :a*,b*.>(Pair ab)a
    = :a*,b*,p(Pair ab).pa(:xa.>bx).

Pi2 : :a*,b*.>(Pair ab)b
    = :a*,b*,p(Pair ab).pb(>a:yb.y).

?? Bool_show (Pi1BoolBool (Mk_pairBoolBool True False)).
?? Bool_show (Pi2BoolBool (Mk_pairBoolBool True False)).

## Natural numbers ##

Nat = :a*.>a>(End a)a.

0 : Nat     = :a*,za,f(End a).z.
S : >NatNat = :xNat,a*,za,f(End a).f(xazf).

"0" : Show.
"S" : Show.
Nat_show
  : >NatShow
  = :xNat.xShow"0"(+"S").

Is_zero : >NatBool = :nNat,a*,xa,ya.nax(>ay).

?? Bool_show (Is_zero(S(S 0))).

Add
  : >Nat>NatNat
  = :nNat,mNat,a*,za,f(End a).ma(nazf)f.

?? Nat_show (Add
              (S(S(S 0)))
              (S(S 0))).

# More Pairs : Pair_show

Pair_show
  : :a*,b*.>(>aShow)>(>bShow)>(Pair ab)Show
  = :a*,b*,f(>aShow),g(>bShow),p(Pair ab).
      + (f(Pi1 abp)) (g(Pi2 abp)).

?? Pair_showNatBoolNat_showBool_show
       (Mk_pairNatBool (Add(S 0)(S 0)) (NotFalse)).

# More Nats : Predecessor

Pred : >NatNat
     = :nNat. Pi2NatNat
        (n (PairNatNat)
           (Mk_pairNatNat 0 0)
           (:p (PairNatNat). Mk_pair Nat Nat (S(Pi1NatNat p)) (Pi1NatNat p))).

?? Nat_show (Pred 0).
?? Nat_show (Pred(S 0)).
?? Nat_show (Pred(S(S 0))).
?? Nat_show (Pred(S(S(S 0)))).

