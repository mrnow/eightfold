# load lib.8f

## Propositions are represented by the Prop type ##

Prop : *.

# Basic connectives
True : Prop.
Imp : End2Prop.
Not : EndProp.
Forall : :a*.>(>aProp)Prop.

## Derivations are represented by the D type constructor ##

D : >Prop*.

# True is derivable
Dtrue : DTrue.

# Natural deduction rules for implication
Impi : :pProp,qProp.>(>(D p)(D q))(D(Imp pq)).
Impe : :pProp,qProp.>(D(Imp pq))>(D p)(D q).

# Natural deduction rules for negation
Noti : :pProp.>(>(D p)(:qProp.D q))(D(Not p)).
Note : :pProp.>(D p)>(D(Not p))(:qProp.D q).

# Classical rule of double negation
Dneg : :pProp.>(D(Not(Not p)))(D p).

##################################################

# Definition of conjunction in terms of negation and implication
And : End2Prop = :pProp,qProp.Not(Imp p(Not q)).

Andi : :pProp,qProp.>(D p)>(D q)(D(And p q))
     = :pProp,qProp,D_p D p,D_q D q.
         # D (Not (Imp p (Not q)))
         Noti (Imp p (Not q))
              (: D_ipnq (D (Imp p (Not q))).
                  # D r
                  Note q
                       D_q                         # D q
                       (Impe p (Not q) D_ipnq D_p) # D (Not q)
              ).

Ande1 : :pProp,qProp.>(D(And pq))(D p)
      = :pProp,qProp,D_apq D(And pq).
            # D p
            Dneg p (
               # D (Not (Not p))
               Noti (Not p)
                    (:D_np D (Not p).
                       # D r
                       Note (Imp p (Not q))
                            # D (Imp p (Not q))
                            (Impi p (Not q) (:D_p (D p). Note p D_p D_np (Not q)))
                            D_apq # D (Not (Imp p (Not q)))
                    )
            ).

Ande2 : :pProp,qProp.>(D(And p q))(D q)
      = :pProp,qProp,D_apq D(And pq).
            # D q
            Dneg q (
                # D (Not (Not q))
                Noti (Not q)
                     (:D_nq D (Not q).
                         # D r
                         Note (Imp p (Not q))
                              (Impi p (Not q) (>(D p)D_nq)) # D (Imp p (Not q))
                              D_apq # D (Not (Imp p (Not q)))
                     )
            ).

? AndiTrueTrue Dtrue Dtrue.
? Ande1TrueTrue (AndiTrueTrue Dtrue Dtrue).
? Ande2TrueTrue (AndiTrueTrue Dtrue Dtrue).

### Definition of disjunction in terms of conjunction and negation

Or : End2Prop = :pProp,qProp.Not(And(Not p)(Not q)).

# Introduction of (p v q) from p
Ori1 : :p Prop, q Prop. > (D p) (D (Or p q))
     = :p Prop, q Prop, D_p D p.
         Noti (And (Not p) (Not q))
              # >(D (And (Not p) (Not q)))(:qProp D q)
              (: D_anpnq (D (And (Not p) (Not q))).
                 # D q
                 Note p
                      D_p                             # D p
                      (Ande1 (Not p) (Not q) D_anpnq) # D (Not p)
              ).

# Introduction of (p v q) from q
Ori2 : :p Prop, q Prop. > (D q) (D (Or p q))
     = :p Prop, q Prop, D_q D q.
         Noti (And (Not p) (Not q))
              # >(D (And (Not p) (Not q)))(:qProp D q)
              (: D_anpnq (D (And (Not p) (Not q))).
                 # D p
                 Note q
                      D_q                             # D q
                      (Ande2 (Not p) (Not q) D_anpnq) # D (Not q)
              ).

# Elimination of (p v q) from (p => r) and (q => r)
# ...

#Imp : End2Prop.
#Exists : :a*.>(>aProp)Prop.
